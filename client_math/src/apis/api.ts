/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = '';

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiResult
 */
export interface ApiResult {
    /**
     * 
     * @type {string}
     * @memberof ApiResult
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResult
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultBlog
 */
export interface ApiResultBlog {
    /**
     * 
     * @type {Blog}
     * @memberof ApiResultBlog
     */
    data?: Blog;
    /**
     * 
     * @type {string}
     * @memberof ApiResultBlog
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultBlog
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultGuid
 */
export interface ApiResultGuid {
    /**
     * 
     * @type {string}
     * @memberof ApiResultGuid
     */
    data?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResultGuid
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultGuid
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultIEnumerableBlog
 */
export interface ApiResultIEnumerableBlog {
    /**
     * 
     * @type {Array<Blog>}
     * @memberof ApiResultIEnumerableBlog
     */
    data?: Array<Blog>;
    /**
     * 
     * @type {string}
     * @memberof ApiResultIEnumerableBlog
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultIEnumerableBlog
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultIEnumerableNodeItem
 */
export interface ApiResultIEnumerableNodeItem {
    /**
     * 
     * @type {Array<NodeItem>}
     * @memberof ApiResultIEnumerableNodeItem
     */
    data?: Array<NodeItem>;
    /**
     * 
     * @type {string}
     * @memberof ApiResultIEnumerableNodeItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultIEnumerableNodeItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultLoginUser
 */
export interface ApiResultLoginUser {
    /**
     * 
     * @type {LoginUser}
     * @memberof ApiResultLoginUser
     */
    data?: LoginUser;
    /**
     * 
     * @type {string}
     * @memberof ApiResultLoginUser
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultLoginUser
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultNodeDir
 */
export interface ApiResultNodeDir {
    /**
     * 
     * @type {NodeDir}
     * @memberof ApiResultNodeDir
     */
    data?: NodeDir;
    /**
     * 
     * @type {string}
     * @memberof ApiResultNodeDir
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultNodeDir
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultNodeItem
 */
export interface ApiResultNodeItem {
    /**
     * 
     * @type {NodeItem}
     * @memberof ApiResultNodeItem
     */
    data?: NodeItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultNodeItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultNodeItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultNodeTag
 */
export interface ApiResultNodeTag {
    /**
     * 
     * @type {NodeTag}
     * @memberof ApiResultNodeTag
     */
    data?: NodeTag;
    /**
     * 
     * @type {string}
     * @memberof ApiResultNodeTag
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultNodeTag
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultCommentItem
 */
export interface ApiResultPagedResultCommentItem {
    /**
     * 
     * @type {PagedResultCommentItem}
     * @memberof ApiResultPagedResultCommentItem
     */
    data?: PagedResultCommentItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultCommentItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultCommentItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultConfigItem
 */
export interface ApiResultPagedResultConfigItem {
    /**
     * 
     * @type {PagedResultConfigItem}
     * @memberof ApiResultPagedResultConfigItem
     */
    data?: PagedResultConfigItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultConfigItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultConfigItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultNodeItem
 */
export interface ApiResultPagedResultNodeItem {
    /**
     * 
     * @type {PagedResultNodeItem}
     * @memberof ApiResultPagedResultNodeItem
     */
    data?: PagedResultNodeItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultNodeItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultNodeItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultRole
 */
export interface ApiResultPagedResultRole {
    /**
     * 
     * @type {PagedResultRole}
     * @memberof ApiResultPagedResultRole
     */
    data?: PagedResultRole;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultRole
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultRole
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultTagItem
 */
export interface ApiResultPagedResultTagItem {
    /**
     * 
     * @type {PagedResultTagItem}
     * @memberof ApiResultPagedResultTagItem
     */
    data?: PagedResultTagItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultTagItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultTagItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultPagedResultUser
 */
export interface ApiResultPagedResultUser {
    /**
     * 
     * @type {PagedResultUser}
     * @memberof ApiResultPagedResultUser
     */
    data?: PagedResultUser;
    /**
     * 
     * @type {string}
     * @memberof ApiResultPagedResultUser
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultPagedResultUser
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultRole
 */
export interface ApiResultRole {
    /**
     * 
     * @type {Role}
     * @memberof ApiResultRole
     */
    data?: Role;
    /**
     * 
     * @type {string}
     * @memberof ApiResultRole
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultRole
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultString
 */
export interface ApiResultString {
    /**
     * 
     * @type {string}
     * @memberof ApiResultString
     */
    data?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResultString
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultString
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultTagItem
 */
export interface ApiResultTagItem {
    /**
     * 
     * @type {TagItem}
     * @memberof ApiResultTagItem
     */
    data?: TagItem;
    /**
     * 
     * @type {string}
     * @memberof ApiResultTagItem
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultTagItem
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface ApiResultUser
 */
export interface ApiResultUser {
    /**
     * 
     * @type {User}
     * @memberof ApiResultUser
     */
    data?: User;
    /**
     * 
     * @type {string}
     * @memberof ApiResultUser
     */
    error?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResultUser
     */
    result?: boolean;
}

/**
 * 
 * @export
 * @interface Blog
 */
export interface Blog {
    /**
     * 
     * @type {string}
     * @memberof Blog
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Blog
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Blog
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof Blog
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CommentItem
 */
export interface CommentItem {
    /**
     * 
     * @type {string}
     * @memberof CommentItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentItem
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentItem
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentItem
     */
    userAvatar?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentItem
     */
    detail?: string;
}

/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    type?: Condition.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    prop?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    value?: string;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Condition
     */
    children?: Array<Condition>;
}

/**
 * @export
 * @namespace Condition
 */
export namespace Condition {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        And = <any> 'And',
        Not = <any> 'Not',
        Or = <any> 'Or',
        Has = <any> 'Has',
        Equal = <any> 'Equal',
        Contains = <any> 'Contains',
        StartsWith = <any> 'StartsWith',
        EndsWith = <any> 'EndsWith',
        GreaterThan = <any> 'GreaterThan',
        GreaterThanOrEqual = <any> 'GreaterThanOrEqual',
        LessThenOrEqual = <any> 'LessThenOrEqual'
    }
}

/**
 * 
 * @export
 * @interface ConfigItem
 */
export interface ConfigItem {
    /**
     * 
     * @type {string}
     * @memberof ConfigItem
     */
    configType?: ConfigItem.ConfigTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConfigItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigItem
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigItem
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigItem
     */
    value?: string;
}

/**
 * @export
 * @namespace ConfigItem
 */
export namespace ConfigItem {
    /**
     * @export
     * @enum {string}
     */
    export enum ConfigTypeEnum {
        None = <any> 'None',
        Boolean = <any> 'Boolean',
        Json = <any> 'Json',
        Image = <any> 'Image'
    }
}

/**
 * 
 * @export
 * @interface Configs
 */
export interface Configs {
    /**
     * 
     * @type {string}
     * @memberof Configs
     */
    appConfigs?: Configs.AppConfigsEnum;
    /**
     * 
     * @type {string}
     * @memberof Configs
     */
    serviceMessages?: Configs.ServiceMessagesEnum;
    /**
     * 
     * @type {string}
     * @memberof Configs
     */
    permissionDescriptions?: Configs.PermissionDescriptionsEnum;
    /**
     * 
     * @type {string}
     * @memberof Configs
     */
    uiLangs?: Configs.UiLangsEnum;
}

/**
 * @export
 * @namespace Configs
 */
export namespace Configs {
    /**
     * @export
     * @enum {string}
     */
    export enum AppConfigsEnum {
        MAXFILESIZE = <any> 'CONFIG_MAX_FILE_SIZE',
        MENUS = <any> 'CONFIG_MENUS',
        EDITORSTYLES = <any> 'CONFIG_EDITOR_STYLES',
        EDITORSTYLETAG = <any> 'CONFIG_EDITOR_STYLE_TAG',
        DAILYTAG = <any> 'CONFIG_DAILY_TAG',
        HEADTAG = <any> 'CONFIG_HEAD_TAG',
        SANDBOXAPPTAG = <any> 'CONFIG_SANDBOX_APP_TAG',
        LOGO = <any> 'CONFIG_LOGO',
        BG = <any> 'CONFIG_BG',
        DEFAULTAVATAR = <any> 'CONFIG_DEFAULT_AVATAR',
        TITLE = <any> 'CONFIG_TITLE',
        DOCTYPETAG = <any> 'CONFIG_DOC_TYPE_TAG',
        SOLUTIONTYPETAG = <any> 'CONFIG_SOLUTION_TYPE_TAG',
        APPTAG = <any> 'CONFIG_APP_TAG',
        SCRIPTTAG = <any> 'CONFIG_SCRIPT_TAG',
        AUTOPLAYTAG = <any> 'CONFIG_AUTOPLAY_TAG',
        PWDEXP = <any> 'CONFIG_PWD_EXP',
        WXAPIURL = <any> 'CONFIG_WX_API_URL',
        WXAPITOKEN = <any> 'CONFIG_WX_API_TOKEN',
        WXJSDOMAIN = <any> 'CONFIG_WX_JS_DOMAIN',
        WXAPPID = <any> 'CONFIG_WX_APP_ID',
        WXAPPSECRET = <any> 'CONFIG_WX_APP_SECRET',
        WXAPIURLTOKEN = <any> 'CONFIG_WX_API_URL_TOKEN',
        WXENABLED = <any> 'CONFIG_WX_ENABLED',
        ICP = <any> 'CONFIG_ICP',
        WXAPIURLMENU = <any> 'CONFIG_WX_API_URL_MENU',
        WXAPIURLSENDALL = <any> 'CONFIG_WX_API_URL_SENDALL',
        WXAPIURLPREVIEW = <any> 'CONFIG_WX_API_URL_PREVIEW',
        WXAPIURLUPLOAD = <any> 'CONFIG_WX_API_URL_UPLOAD',
        WXAPIURLUPLOADIMG = <any> 'CONFIG_WX_API_URL_UPLOAD_IMG',
        WXAPIPREVIEWUSERID = <any> 'CONFIG_WX_API_PREVIEW_USERID',
        WXAPIURLUPLOADNEWS = <any> 'CONFIG_WX_API_URL_UPLOAD_NEWS',
        WXAPIURLDELETEMSG = <any> 'CONFIG_WX_API_URL_DELETE_MSG',
        HOMEURL = <any> 'CONFIG_HOME_URL',
        WXSHARETAG = <any> 'CONFIG_WX_SHARE_TAG',
        WXSHAREDEFAULTTHUMB = <any> 'CONFIG_WX_SHARE_DEFAULT_THUMB',
        WXSHAREDEFAULTTHUMBID = <any> 'CONFIG_WX_SHARE_DEFAULT_THUMB_ID',
        WXSHAREMAXARTICLECOUNT = <any> 'CONFIG_WX_SHARE_MAX_ARTICLE_COUNT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceMessagesEnum {
        SiteConfigError = <any> 'SiteConfigError',
        FileToLarge = <any> 'FileToLarge',
        ClientError = <any> 'ClientError',
        ConflictRoleName = <any> 'ConflictRoleName',
        ConflictNodeName = <any> 'ConflictNodeName',
        ConflictUserName = <any> 'ConflictUserName',
        InvalidPwd = <any> 'InvalidPwd',
        InvalidRoleName = <any> 'InvalidRoleName',
        InvalidUserName = <any> 'InvalidUserName',
        InvalidNodeName = <any> 'InvalidNodeName',
        InvalidUserState = <any> 'InvalidUserState',
        NeedRelogin = <any> 'NeedRelogin',
        NoPermission = <any> 'NoPermission',
        NoSuchBaseRole = <any> 'NoSuchBaseRole',
        NoSuchPermission = <any> 'NoSuchPermission',
        NoSuchRole = <any> 'NoSuchRole',
        NoSuchUser = <any> 'NoSuchUser',
        NotLogin = <any> 'NotLogin',
        ServerError = <any> 'ServerError',
        UserOrPwdError = <any> 'UserOrPwdError',
        NoSuchFolder = <any> 'NoSuchFolder',
        NoSuchFile = <any> 'NoSuchFile',
        NoSuchNode = <any> 'NoSuchNode',
        InvalidFileType = <any> 'InvalidFileType',
        ConflictTagName = <any> 'ConflictTagName',
        NoSuchTag = <any> 'NoSuchTag',
        InvalidTagName = <any> 'InvalidTagName',
        InvalidTagValues = <any> 'InvalidTagValues',
        NoSuchLang = <any> 'NoSuchLang',
        InvalidQuery = <any> 'InvalidQuery',
        NoSuchComment = <any> 'NoSuchComment'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PermissionDescriptionsEnum {
        MANAGE = <any> 'PERMISSION_MANAGE',
        POSTBLOG = <any> 'PERMISSION_POST_BLOG',
        REPLYSOLUTION = <any> 'PERMISSION_REPLY_SOLUTION',
        SHAREBLOG = <any> 'PERMISSION_SHARE_BLOG',
        COMMENT = <any> 'PERMISSION_COMMENT',
        THIRDSHARE = <any> 'PERMISSION_THIRD_SHARE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UiLangsEnum {
        Home = <any> 'Home',
        Library = <any> 'Library',
        Name = <any> 'Name',
        UserName = <any> 'UserName',
        Password = <any> 'Password',
        Manage = <any> 'Manage',
        User = <any> 'User',
        Role = <any> 'Role',
        State = <any> 'State',
        Normal = <any> 'Normal',
        Disabled = <any> 'Disabled',
        Search = <any> 'Search',
        Create = <any> 'Create',
        Permission = <any> 'Permission',
        Delete = <any> 'Delete',
        RootNode = <any> 'RootNode',
        AddSolution = <any> 'AddSolution',
        Solution = <any> 'Solution',
        Folder = <any> 'Folder',
        Blog = <any> 'Blog',
        NoSolution = <any> 'NoSolution',
        Select = <any> 'Select',
        Ok = <any> 'Ok',
        Preview = <any> 'Preview',
        Cancle = <any> 'Cancle',
        ConfirmNameToDelete = <any> 'ConfirmNameToDelete',
        Tags = <any> 'Tags',
        Type = <any> 'Type',
        Value = <any> 'Value',
        Values = <any> 'Values',
        None = <any> 'None',
        Bool = <any> 'Bool',
        String = <any> 'String',
        Enum = <any> 'Enum',
        Number = <any> 'Number',
        Url = <any> 'Url',
        Private = <any> 'Private',
        Modify = <any> 'Modify',
        Key = <any> 'Key',
        DefaultValue = <any> 'DefaultValue',
        Reset = <any> 'Reset',
        Configs = <any> 'Configs',
        Login = <any> 'Login',
        Logout = <any> 'Logout',
        History = <any> 'History',
        Mine = <any> 'Mine',
        MySolution = <any> 'MySolution',
        SolutionTo = <any> 'SolutionTo',
        ReplySolution = <any> 'ReplySolution',
        ViewSolution = <any> 'ViewSolution',
        MySolutions = <any> 'MySolutions',
        ImageEditor = <any> 'ImageEditor',
        LoadMore = <any> 'LoadMore',
        Comment = <any> 'Comment',
        ChangePwd = <any> 'ChangePwd',
        NewPassword = <any> 'NewPassword',
        PasswordNotSame = <any> 'PasswordNotSame',
        LivePreview = <any> 'LivePreview',
        BlogEditor = <any> 'BlogEditor',
        DataWillNotSave = <any> 'DataWillNotSave',
        Python = <any> 'Python',
        CommentSuccess = <any> 'CommentSuccess',
        NoCommentsWelcomeToAdd = <any> 'NoCommentsWelcomeToAdd',
        Run = <any> 'Run',
        TmpFileWillNotSave = <any> 'TmpFileWillNotSave',
        NoWxTokenFound = <any> 'NoWxTokenFound',
        InvalidApiSignature = <any> 'InvalidApiSignature',
        Reference = <any> 'Reference',
        PwdDescription = <any> 'PwdDescription',
        PythonConsole = <any> 'PythonConsole',
        OpenFile = <any> 'OpenFile',
        SuccessToCopy = <any> 'SuccessToCopy',
        OpenFileFromThisApp = <any> 'OpenFileFromThisApp'
    }
}

/**
 * 
 * @export
 * @interface LoginUser
 */
export interface LoginUser {
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    nickName?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof LoginUser
     */
    permissions?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    roleName?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface NewPwd
 */
export interface NewPwd {
    /**
     * 
     * @type {string}
     * @memberof NewPwd
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof NewPwd
     */
    password: string;
}

/**
 * 
 * @export
 * @interface NewRole
 */
export interface NewRole {
    /**
     * 
     * @type {string}
     * @memberof NewRole
     */
    baseRoleId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewRole
     */
    name: string;
}

/**
 * 
 * @export
 * @interface NewUser
 */
export interface NewUser {
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    pwd: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    roleId?: string;
}

/**
 * 
 * @export
 * @interface NodeDir
 */
export interface NodeDir {
    /**
     * 
     * @type {Array<NodeItem>}
     * @memberof NodeDir
     */
    subnodes?: Array<NodeItem>;
    /**
     * 
     * @type {Array<NodeItem>}
     * @memberof NodeDir
     */
    supnodes?: Array<NodeItem>;
}

/**
 * 
 * @export
 * @interface NodeItem
 */
export interface NodeItem {
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    id?: string;
    /**
     * 
     * @type {NodeReference}
     * @memberof NodeItem
     */
    reference?: NodeReference;
    /**
     * 
     * @type {Date}
     * @memberof NodeItem
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NodeItem
     */
    modified?: Date;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NodeItem
     */
    hasSolution?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    solutionToId?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    solutionTo?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    type?: NodeItem.TypeEnum;
    /**
     * 
     * @type {NodeUser}
     * @memberof NodeItem
     */
    user?: NodeUser;
    /**
     * 
     * @type {string}
     * @memberof NodeItem
     */
    content?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NodeItem
     */
    shared?: boolean;
    /**
     * 
     * @type {Array<NodeTag>}
     * @memberof NodeItem
     */
    tags?: Array<NodeTag>;
}

/**
 * @export
 * @namespace NodeItem
 */
export namespace NodeItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        Folder = <any> 'Folder',
        Blog = <any> 'Blog',
        Reference = <any> 'Reference'
    }
}

/**
 * 
 * @export
 * @interface NodeReference
 */
export interface NodeReference {
    /**
     * 
     * @type {string}
     * @memberof NodeReference
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeReference
     */
    type?: NodeReference.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NodeReference
     */
    content?: string;
    /**
     * 
     * @type {Array<NodeTag>}
     * @memberof NodeReference
     */
    tags?: Array<NodeTag>;
}

/**
 * @export
 * @namespace NodeReference
 */
export namespace NodeReference {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        Folder = <any> 'Folder',
        Blog = <any> 'Blog',
        Reference = <any> 'Reference'
    }
}

/**
 * 
 * @export
 * @interface NodeTag
 */
export interface NodeTag {
    /**
     * 
     * @type {string}
     * @memberof NodeTag
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeTag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeTag
     */
    type?: NodeTag.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NodeTag
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeTag
     */
    values?: string;
}

/**
 * @export
 * @namespace NodeTag
 */
export namespace NodeTag {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        Bool = <any> 'Bool',
        String = <any> 'String',
        Number = <any> 'Number',
        Enum = <any> 'Enum',
        Url = <any> 'Url',
        Private = <any> 'Private'
    }
}

/**
 * 
 * @export
 * @interface NodeUser
 */
export interface NodeUser {
    /**
     * 
     * @type {string}
     * @memberof NodeUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeUser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeUser
     */
    nickName?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeUser
     */
    avatar?: string;
}

/**
 * 
 * @export
 * @interface PagedResultCommentItem
 */
export interface PagedResultCommentItem {
    /**
     * 
     * @type {Array<CommentItem>}
     * @memberof PagedResultCommentItem
     */
    data?: Array<CommentItem>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultCommentItem
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface PagedResultConfigItem
 */
export interface PagedResultConfigItem {
    /**
     * 
     * @type {Array<ConfigItem>}
     * @memberof PagedResultConfigItem
     */
    data?: Array<ConfigItem>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultConfigItem
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface PagedResultNodeItem
 */
export interface PagedResultNodeItem {
    /**
     * 
     * @type {Array<NodeItem>}
     * @memberof PagedResultNodeItem
     */
    data?: Array<NodeItem>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultNodeItem
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface PagedResultRole
 */
export interface PagedResultRole {
    /**
     * 
     * @type {Array<Role>}
     * @memberof PagedResultRole
     */
    data?: Array<Role>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultRole
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface PagedResultTagItem
 */
export interface PagedResultTagItem {
    /**
     * 
     * @type {Array<TagItem>}
     * @memberof PagedResultTagItem
     */
    data?: Array<TagItem>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultTagItem
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface PagedResultUser
 */
export interface PagedResultUser {
    /**
     * 
     * @type {Array<User>}
     * @memberof PagedResultUser
     */
    data?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof PagedResultUser
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {string}
     * @memberof Query
     */
    parent?: string;
    /**
     * 
     * @type {Condition}
     * @memberof Query
     */
    where?: Condition;
    /**
     * 
     * @type {string}
     * @memberof Query
     */
    orderBy?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Query
     */
    orderByDesc?: boolean;
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof Role
     */
    permissions?: { [key: string]: boolean; };
}

/**
 * 
 * @export
 * @interface TagItem
 */
export interface TagItem {
    /**
     * 
     * @type {string}
     * @memberof TagItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagItem
     */
    type?: TagItem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagItem
     */
    values?: string;
}

/**
 * @export
 * @namespace TagItem
 */
export namespace TagItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        Bool = <any> 'Bool',
        String = <any> 'String',
        Number = <any> 'Number',
        Enum = <any> 'Enum',
        Url = <any> 'Url',
        Private = <any> 'Private'
    }
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nickName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    roleId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    state?: User.StateEnum;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ToApprove = <any> 'ToApprove',
        Normal = <any> 'Normal',
        Disabled = <any> 'Disabled'
    }
}

/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    password: string;
}


/**
 * CommentApi - fetch parameter creator
 * @export
 */
export const CommentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} blogId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(blogId: string, detail: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling addComment.');
            }
            // verify required parameter 'detail' is not null or undefined
            if (detail === null || detail === undefined) {
                throw new RequiredError('detail','Required parameter detail was null or undefined when calling addComment.');
            }
            const localVarPath = `/api/Comment/AddComment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubcomment(commentId: string, detail: string, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling addSubcomment.');
            }
            // verify required parameter 'detail' is not null or undefined
            if (detail === null || detail === undefined) {
                throw new RequiredError('detail','Required parameter detail was null or undefined when calling addSubcomment.');
            }
            const localVarPath = `/api/Comment/AddSubcomment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commentId !== undefined) {
                localVarQueryParameter['commentId'] = commentId;
            }

            if (detail !== undefined) {
                localVarQueryParameter['detail'] = detail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling deleteComment.');
            }
            const localVarPath = `/api/Comment/DeleteComment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commentId !== undefined) {
                localVarQueryParameter['commentId'] = commentId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogComments(blogId: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogComments.');
            }
            const localVarPath = `/api/Comment/GetBlogComments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubcomments(commentId: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling getSubcomments.');
            }
            const localVarPath = `/api/Comment/GetSubcomments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commentId !== undefined) {
                localVarQueryParameter['commentId'] = commentId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentApi - functional programming interface
 * @export
 */
export const CommentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} blogId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(blogId: string, detail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultGuid> {
            const localVarFetchArgs = CommentApiFetchParamCreator(configuration).addComment(blogId, detail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubcomment(commentId: string, detail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = CommentApiFetchParamCreator(configuration).addSubcomment(commentId, detail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = CommentApiFetchParamCreator(configuration).deleteComment(commentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogComments(blogId: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultCommentItem> {
            const localVarFetchArgs = CommentApiFetchParamCreator(configuration).getBlogComments(blogId, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} commentId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubcomments(commentId: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultCommentItem> {
            const localVarFetchArgs = CommentApiFetchParamCreator(configuration).getSubcomments(commentId, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommentApi - factory interface
 * @export
 */
export const CommentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} blogId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(blogId: string, detail: string, options?: any) {
            return CommentApiFp(configuration).addComment(blogId, detail, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} commentId 
         * @param {string} detail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubcomment(commentId: string, detail: string, options?: any) {
            return CommentApiFp(configuration).addSubcomment(commentId, detail, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(commentId: string, options?: any) {
            return CommentApiFp(configuration).deleteComment(commentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogComments(blogId: string, skip?: number, count?: number, options?: any) {
            return CommentApiFp(configuration).getBlogComments(blogId, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} commentId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubcomments(commentId: string, skip?: number, count?: number, options?: any) {
            return CommentApiFp(configuration).getSubcomments(commentId, skip, count, options)(fetch, basePath);
        },
    };
};

/**
 * CommentApi - object-oriented interface
 * @export
 * @class CommentApi
 * @extends {BaseAPI}
 */
export class CommentApi extends BaseAPI {
    /**
     * 
     * @param {string} blogId 
     * @param {string} detail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public addComment(blogId: string, detail: string, options?: any) {
        return CommentApiFp(this.configuration).addComment(blogId, detail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} commentId 
     * @param {string} detail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public addSubcomment(commentId: string, detail: string, options?: any) {
        return CommentApiFp(this.configuration).addSubcomment(commentId, detail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public deleteComment(commentId: string, options?: any) {
        return CommentApiFp(this.configuration).deleteComment(commentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public getBlogComments(blogId: string, skip?: number, count?: number, options?: any) {
        return CommentApiFp(this.configuration).getBlogComments(blogId, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} commentId 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentApi
     */
    public getSubcomments(commentId: string, skip?: number, count?: number, options?: any) {
        return CommentApiFp(this.configuration).getSubcomments(commentId, skip, count, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigsApi - fetch parameter creator
 * @export
 */
export const ConfigsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options: any = {}): FetchArgs {
            const localVarPath = `/api/Configs/All`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allConfigs(filter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Configs/AllConfigs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allKeys(options: any = {}): FetchArgs {
            const localVarPath = `/api/Configs/AllKeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetValue(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resetValue.');
            }
            const localVarPath = `/api/Configs/ResetValue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageValue(id: string, file: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateImageValue.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling updateImageValue.');
            }
            const localVarPath = `/api/Configs/UpdateImageValue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateValue(id: string, value: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateValue.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling updateValue.');
            }
            const localVarPath = `/api/Configs/UpdateValue`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(value || {}) : (value || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigsApi - functional programming interface
 * @export
 */
export const ConfigsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).all(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allConfigs(filter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultConfigItem> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).allConfigs(filter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allKeys(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Configs> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).allKeys(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetValue(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).resetValue(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageValue(id: string, file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).updateImageValue(id, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateValue(id: string, value: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = ConfigsApiFetchParamCreator(configuration).updateValue(id, value, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigsApi - factory interface
 * @export
 */
export const ConfigsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        all(options?: any) {
            return ConfigsApiFp(configuration).all(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allConfigs(filter?: string, skip?: number, count?: number, options?: any) {
            return ConfigsApiFp(configuration).allConfigs(filter, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allKeys(options?: any) {
            return ConfigsApiFp(configuration).allKeys(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetValue(id: string, options?: any) {
            return ConfigsApiFp(configuration).resetValue(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageValue(id: string, file: any, options?: any) {
            return ConfigsApiFp(configuration).updateImageValue(id, file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateValue(id: string, value: string, options?: any) {
            return ConfigsApiFp(configuration).updateValue(id, value, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigsApi - object-oriented interface
 * @export
 * @class ConfigsApi
 * @extends {BaseAPI}
 */
export class ConfigsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public all(options?: any) {
        return ConfigsApiFp(this.configuration).all(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [filter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public allConfigs(filter?: string, skip?: number, count?: number, options?: any) {
        return ConfigsApiFp(this.configuration).allConfigs(filter, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public allKeys(options?: any) {
        return ConfigsApiFp(this.configuration).allKeys(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public resetValue(id: string, options?: any) {
        return ConfigsApiFp(this.configuration).resetValue(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public updateImageValue(id: string, file: any, options?: any) {
        return ConfigsApiFp(this.configuration).updateImageValue(id, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public updateValue(id: string, value: string, options?: any) {
        return ConfigsApiFp(this.configuration).updateValue(id, value, options)(this.fetch, this.basePath);
    }

}

/**
 * FilesApi - fetch parameter creator
 * @export
 */
export const FilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/api/Files/UploadFile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).uploadFile(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file: any, options?: any) {
            return FilesApiFp(configuration).uploadFile(file, options)(fetch, basePath);
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadFile(file: any, options?: any) {
        return FilesApiFp(this.configuration).uploadFile(file, options)(this.fetch, this.basePath);
    }

}

/**
 * LoginApi - fetch parameter creator
 * @export
 */
export const LoginApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        off(options: any = {}): FetchArgs {
            const localVarPath = `/api/Login/Off`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        on(options: any = {}): FetchArgs {
            const localVarPath = `/api/Login/On`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLogin} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pwdOn(login: UserLogin, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login','Required parameter login was null or undefined when calling pwdOn.');
            }
            const localVarPath = `/api/Login/PwdOn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserLogin" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(login || {}) : (login || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling updateAvatar.');
            }
            const localVarPath = `/api/Login/UpdateAvatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nickName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickName(nickName: string, options: any = {}): FetchArgs {
            // verify required parameter 'nickName' is not null or undefined
            if (nickName === null || nickName === undefined) {
                throw new RequiredError('nickName','Required parameter nickName was null or undefined when calling updateNickName.');
            }
            const localVarPath = `/api/Login/UpdateNickName`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nickName !== undefined) {
                localVarQueryParameter['nickName'] = nickName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewPwd} newpwd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePwd(newpwd: NewPwd, options: any = {}): FetchArgs {
            // verify required parameter 'newpwd' is not null or undefined
            if (newpwd === null || newpwd === undefined) {
                throw new RequiredError('newpwd','Required parameter newpwd was null or undefined when calling updatePwd.');
            }
            const localVarPath = `/api/Login/UpdatePwd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewPwd" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(newpwd || {}) : (newpwd || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatAppId(options: any = {}): FetchArgs {
            const localVarPath = `/api/Login/WeChatAppId`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [testLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatOn(code: string, testLogin?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling weChatOn.');
            }
            const localVarPath = `/api/Login/WeChatOn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (testLogin !== undefined) {
                localVarQueryParameter['testLogin'] = testLogin;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        off(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).off(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        on(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultLoginUser> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).on(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserLogin} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pwdOn(login: UserLogin, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultLoginUser> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).pwdOn(login, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).updateAvatar(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nickName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickName(nickName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).updateNickName(nickName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NewPwd} newpwd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePwd(newpwd: NewPwd, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).updatePwd(newpwd, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatAppId(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).weChatAppId(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [testLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatOn(code: string, testLogin?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultLoginUser> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).weChatOn(code, testLogin, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        off(options?: any) {
            return LoginApiFp(configuration).off(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        on(options?: any) {
            return LoginApiFp(configuration).on(options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserLogin} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pwdOn(login: UserLogin, options?: any) {
            return LoginApiFp(configuration).pwdOn(login, options)(fetch, basePath);
        },
        /**
         * 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatar(file: any, options?: any) {
            return LoginApiFp(configuration).updateAvatar(file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nickName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickName(nickName: string, options?: any) {
            return LoginApiFp(configuration).updateNickName(nickName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NewPwd} newpwd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePwd(newpwd: NewPwd, options?: any) {
            return LoginApiFp(configuration).updatePwd(newpwd, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatAppId(options?: any) {
            return LoginApiFp(configuration).weChatAppId(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {boolean} [testLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weChatOn(code: string, testLogin?: boolean, options?: any) {
            return LoginApiFp(configuration).weChatOn(code, testLogin, options)(fetch, basePath);
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public off(options?: any) {
        return LoginApiFp(this.configuration).off(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public on(options?: any) {
        return LoginApiFp(this.configuration).on(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UserLogin} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public pwdOn(login: UserLogin, options?: any) {
        return LoginApiFp(this.configuration).pwdOn(login, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public updateAvatar(file: any, options?: any) {
        return LoginApiFp(this.configuration).updateAvatar(file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nickName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public updateNickName(nickName: string, options?: any) {
        return LoginApiFp(this.configuration).updateNickName(nickName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NewPwd} newpwd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public updatePwd(newpwd: NewPwd, options?: any) {
        return LoginApiFp(this.configuration).updatePwd(newpwd, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public weChatAppId(options?: any) {
        return LoginApiFp(this.configuration).weChatAppId(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} code 
     * @param {boolean} [testLogin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public weChatOn(code: string, testLogin?: boolean, options?: any) {
        return LoginApiFp(this.configuration).weChatOn(code, testLogin, options)(this.fetch, this.basePath);
    }

}

/**
 * NodesApi - fetch parameter creator
 * @export
 */
export const NodesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} nodeId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allLevelNodes(nodeId: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling allLevelNodes.');
            }
            const localVarPath = `/api/Nodes/AllLevelNodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Folder' | 'Blog' | 'Reference'} type 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(name: string, type: 'None' | 'Folder' | 'Blog' | 'Reference', parentId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createNode.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createNode.');
            }
            const localVarPath = `/api/Nodes/CreateNode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateBlogContent(path: string, content?: string, options: any = {}): FetchArgs {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling createOrUpdateBlogContent.');
            }
            const localVarPath = `/api/Nodes/CreateOrUpdateBlogContent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(content || {}) : (content || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [parentId] 
         * @param {string} [refId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefNode(name?: string, parentId?: string, refId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/CreateRefNode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (refId !== undefined) {
                localVarQueryParameter['refId'] = refId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTempBlogFiles(blogId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteTempBlogFiles.');
            }
            const localVarPath = `/api/Nodes/DeleteTempBlogFiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlog(blogId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlog.');
            }
            const localVarPath = `/api/Nodes/GetBlog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogCustomSolution(blogId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogCustomSolution.');
            }
            const localVarPath = `/api/Nodes/GetBlogCustomSolution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogDefaultSolution(blogId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogDefaultSolution.');
            }
            const localVarPath = `/api/Nodes/GetBlogDefaultSolution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogSolutions(blogId: string, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogSolutions.');
            }
            const localVarPath = `/api/Nodes/GetBlogSolutions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tag 
         * @param {string} [tagValue] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsByTag(tag: string, tagValue?: string, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getBlogsByTag.');
            }
            const localVarPath = `/api/Nodes/GetBlogsByTag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tagValue'] = tagValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(nodeId?: string, folderId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/Move`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeDir(nodeId?: string, filter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/NodeDir`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathNodes(nodeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling pathNodes.');
            }
            const localVarPath = `/api/Nodes/PathNodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Query} query 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryNodes(query: Query, filter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling queryNodes.');
            }
            const localVarPath = `/api/Nodes/QueryNodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNode(nodeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling removeNode.');
            }
            const localVarPath = `/api/Nodes/RemoveNode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(nodeId: string, tagId: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling removeTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling removeTag.');
            }
            const localVarPath = `/api/Nodes/RemoveTag/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [newName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(nodeId?: string, newName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/Rename`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['newName'] = newName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subNodesOrFilterAllSubNodes(nodeId?: string, filter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/SubNodesOrFilterAllSubNodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogContent(blogId: string, content?: string, files?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling updateBlogContent.');
            }
            const localVarPath = `/api/Nodes/UpdateBlogContent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            if (files) {
                localVarQueryParameter['files'] = files;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(content || {}) : (content || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [title] 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogSolution(blogId: string, title?: string, content?: string, files?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling updateBlogSolution.');
            }
            const localVarPath = `/api/Nodes/UpdateBlogSolution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blogId !== undefined) {
                localVarQueryParameter['blogId'] = blogId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (files) {
                localVarQueryParameter['files'] = files;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(content || {}) : (content || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeGroupShared(nodeId?: string, shared?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/UpdateNodeGroupShared`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeShared(nodeId?: string, shared?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/Nodes/UpdateNodeShared`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {string} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(nodeId: string, tagId: string, value?: string, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling updateTag.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling updateTag.');
            }
            const localVarPath = `/api/Nodes/UpdateTag/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (tagId !== undefined) {
                localVarQueryParameter['tagId'] = tagId;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {boolean} share 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWxShare(nodeId: string, share: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling updateWxShare.');
            }
            // verify required parameter 'share' is not null or undefined
            if (share === null || share === undefined) {
                throw new RequiredError('share','Required parameter share was null or undefined when calling updateWxShare.');
            }
            const localVarPath = `/api/Nodes/UpdateWxShare/share`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nodeId !== undefined) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (share !== undefined) {
                localVarQueryParameter['share'] = share;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} nodeId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allLevelNodes(nodeId: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).allLevelNodes(nodeId, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Folder' | 'Blog' | 'Reference'} type 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(name: string, type: 'None' | 'Folder' | 'Blog' | 'Reference', parentId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).createNode(name, type, parentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {string} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateBlogContent(path: string, content?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).createOrUpdateBlogContent(path, content, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [parentId] 
         * @param {string} [refId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefNode(name?: string, parentId?: string, refId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).createRefNode(name, parentId, refId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTempBlogFiles(blogId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).deleteTempBlogFiles(blogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlog(blogId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBlog> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getBlog(blogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogCustomSolution(blogId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBlog> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getBlogCustomSolution(blogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogDefaultSolution(blogId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBlog> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getBlogDefaultSolution(blogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogSolutions(blogId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultIEnumerableBlog> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getBlogSolutions(blogId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tag 
         * @param {string} [tagValue] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsByTag(tag: string, tagValue?: string, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).getBlogsByTag(tag, tagValue, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(nodeId?: string, folderId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).move(nodeId, folderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeDir(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNodeDir> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).nodeDir(nodeId, filter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathNodes(nodeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultIEnumerableNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).pathNodes(nodeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Query} query 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryNodes(query: Query, filter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).queryNodes(query, filter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNode(nodeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).removeNode(nodeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(nodeId: string, tagId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).removeTag(nodeId, tagId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [newName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(nodeId?: string, newName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).rename(nodeId, newName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subNodesOrFilterAllSubNodes(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultNodeItem> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).subNodesOrFilterAllSubNodes(nodeId, filter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogContent(blogId: string, content?: string, files?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateBlogContent(blogId, content, files, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [title] 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogSolution(blogId: string, title?: string, content?: string, files?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultGuid> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateBlogSolution(blogId, title, content, files, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeGroupShared(nodeId?: string, shared?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateNodeGroupShared(nodeId, shared, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeShared(nodeId?: string, shared?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateNodeShared(nodeId, shared, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {string} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(nodeId: string, tagId: string, value?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateTag(nodeId, tagId, value, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {boolean} share 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWxShare(nodeId: string, share: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNodeTag> {
            const localVarFetchArgs = NodesApiFetchParamCreator(configuration).updateWxShare(nodeId, share, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} nodeId 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allLevelNodes(nodeId: string, skip?: number, count?: number, options?: any) {
            return NodesApiFp(configuration).allLevelNodes(nodeId, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Folder' | 'Blog' | 'Reference'} type 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(name: string, type: 'None' | 'Folder' | 'Blog' | 'Reference', parentId?: string, options?: any) {
            return NodesApiFp(configuration).createNode(name, type, parentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} path 
         * @param {string} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateBlogContent(path: string, content?: string, options?: any) {
            return NodesApiFp(configuration).createOrUpdateBlogContent(path, content, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [parentId] 
         * @param {string} [refId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefNode(name?: string, parentId?: string, refId?: string, options?: any) {
            return NodesApiFp(configuration).createRefNode(name, parentId, refId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTempBlogFiles(blogId: string, options?: any) {
            return NodesApiFp(configuration).deleteTempBlogFiles(blogId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlog(blogId: string, options?: any) {
            return NodesApiFp(configuration).getBlog(blogId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogCustomSolution(blogId: string, options?: any) {
            return NodesApiFp(configuration).getBlogCustomSolution(blogId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogDefaultSolution(blogId: string, options?: any) {
            return NodesApiFp(configuration).getBlogDefaultSolution(blogId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogSolutions(blogId: string, options?: any) {
            return NodesApiFp(configuration).getBlogSolutions(blogId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tag 
         * @param {string} [tagValue] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsByTag(tag: string, tagValue?: string, count?: number, options?: any) {
            return NodesApiFp(configuration).getBlogsByTag(tag, tagValue, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(nodeId?: string, folderId?: string, options?: any) {
            return NodesApiFp(configuration).move(nodeId, folderId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeDir(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any) {
            return NodesApiFp(configuration).nodeDir(nodeId, filter, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathNodes(nodeId: string, options?: any) {
            return NodesApiFp(configuration).pathNodes(nodeId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Query} query 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryNodes(query: Query, filter?: string, skip?: number, count?: number, options?: any) {
            return NodesApiFp(configuration).queryNodes(query, filter, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNode(nodeId: string, options?: any) {
            return NodesApiFp(configuration).removeNode(nodeId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(nodeId: string, tagId: string, options?: any) {
            return NodesApiFp(configuration).removeTag(nodeId, tagId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [newName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(nodeId?: string, newName?: string, options?: any) {
            return NodesApiFp(configuration).rename(nodeId, newName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subNodesOrFilterAllSubNodes(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any) {
            return NodesApiFp(configuration).subNodesOrFilterAllSubNodes(nodeId, filter, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogContent(blogId: string, content?: string, files?: Array<string>, options?: any) {
            return NodesApiFp(configuration).updateBlogContent(blogId, content, files, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} blogId 
         * @param {string} [title] 
         * @param {string} [content] 
         * @param {Array<string>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogSolution(blogId: string, title?: string, content?: string, files?: Array<string>, options?: any) {
            return NodesApiFp(configuration).updateBlogSolution(blogId, title, content, files, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeGroupShared(nodeId?: string, shared?: boolean, options?: any) {
            return NodesApiFp(configuration).updateNodeGroupShared(nodeId, shared, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nodeId] 
         * @param {boolean} [shared] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeShared(nodeId?: string, shared?: boolean, options?: any) {
            return NodesApiFp(configuration).updateNodeShared(nodeId, shared, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {string} tagId 
         * @param {string} [value] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(nodeId: string, tagId: string, value?: string, options?: any) {
            return NodesApiFp(configuration).updateTag(nodeId, tagId, value, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} nodeId 
         * @param {boolean} share 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWxShare(nodeId: string, share: boolean, options?: any) {
            return NodesApiFp(configuration).updateWxShare(nodeId, share, options)(fetch, basePath);
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @param {string} nodeId 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public allLevelNodes(nodeId: string, skip?: number, count?: number, options?: any) {
        return NodesApiFp(this.configuration).allLevelNodes(nodeId, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {'None' | 'Folder' | 'Blog' | 'Reference'} type 
     * @param {string} [parentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createNode(name: string, type: 'None' | 'Folder' | 'Blog' | 'Reference', parentId?: string, options?: any) {
        return NodesApiFp(this.configuration).createNode(name, type, parentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} path 
     * @param {string} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createOrUpdateBlogContent(path: string, content?: string, options?: any) {
        return NodesApiFp(this.configuration).createOrUpdateBlogContent(path, content, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {string} [parentId] 
     * @param {string} [refId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createRefNode(name?: string, parentId?: string, refId?: string, options?: any) {
        return NodesApiFp(this.configuration).createRefNode(name, parentId, refId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public deleteTempBlogFiles(blogId: string, options?: any) {
        return NodesApiFp(this.configuration).deleteTempBlogFiles(blogId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getBlog(blogId: string, options?: any) {
        return NodesApiFp(this.configuration).getBlog(blogId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getBlogCustomSolution(blogId: string, options?: any) {
        return NodesApiFp(this.configuration).getBlogCustomSolution(blogId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getBlogDefaultSolution(blogId: string, options?: any) {
        return NodesApiFp(this.configuration).getBlogDefaultSolution(blogId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getBlogSolutions(blogId: string, options?: any) {
        return NodesApiFp(this.configuration).getBlogSolutions(blogId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tag 
     * @param {string} [tagValue] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getBlogsByTag(tag: string, tagValue?: string, count?: number, options?: any) {
        return NodesApiFp(this.configuration).getBlogsByTag(tag, tagValue, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {string} [folderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public move(nodeId?: string, folderId?: string, options?: any) {
        return NodesApiFp(this.configuration).move(nodeId, folderId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {string} [filter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public nodeDir(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any) {
        return NodesApiFp(this.configuration).nodeDir(nodeId, filter, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public pathNodes(nodeId: string, options?: any) {
        return NodesApiFp(this.configuration).pathNodes(nodeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Query} query 
     * @param {string} [filter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public queryNodes(query: Query, filter?: string, skip?: number, count?: number, options?: any) {
        return NodesApiFp(this.configuration).queryNodes(query, filter, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public removeNode(nodeId: string, options?: any) {
        return NodesApiFp(this.configuration).removeNode(nodeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public removeTag(nodeId: string, tagId: string, options?: any) {
        return NodesApiFp(this.configuration).removeTag(nodeId, tagId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {string} [newName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public rename(nodeId?: string, newName?: string, options?: any) {
        return NodesApiFp(this.configuration).rename(nodeId, newName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {string} [filter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public subNodesOrFilterAllSubNodes(nodeId?: string, filter?: string, skip?: number, count?: number, options?: any) {
        return NodesApiFp(this.configuration).subNodesOrFilterAllSubNodes(nodeId, filter, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {string} [content] 
     * @param {Array<string>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateBlogContent(blogId: string, content?: string, files?: Array<string>, options?: any) {
        return NodesApiFp(this.configuration).updateBlogContent(blogId, content, files, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} blogId 
     * @param {string} [title] 
     * @param {string} [content] 
     * @param {Array<string>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateBlogSolution(blogId: string, title?: string, content?: string, files?: Array<string>, options?: any) {
        return NodesApiFp(this.configuration).updateBlogSolution(blogId, title, content, files, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {boolean} [shared] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNodeGroupShared(nodeId?: string, shared?: boolean, options?: any) {
        return NodesApiFp(this.configuration).updateNodeGroupShared(nodeId, shared, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nodeId] 
     * @param {boolean} [shared] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNodeShared(nodeId?: string, shared?: boolean, options?: any) {
        return NodesApiFp(this.configuration).updateNodeShared(nodeId, shared, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId 
     * @param {string} tagId 
     * @param {string} [value] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateTag(nodeId: string, tagId: string, value?: string, options?: any) {
        return NodesApiFp(this.configuration).updateTag(nodeId, tagId, value, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} nodeId 
     * @param {boolean} share 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateWxShare(nodeId: string, share: boolean, options?: any) {
        return NodesApiFp(this.configuration).updateWxShare(nodeId, share, options)(this.fetch, this.basePath);
    }

}

/**
 * RolesApi - fetch parameter creator
 * @export
 */
export const RolesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRole(roleId: string, permission: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling addPermissionToRole.');
            }
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new RequiredError('permission','Required parameter permission was null or undefined when calling addPermissionToRole.');
            }
            const localVarPath = `/api/Roles/permission`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewRole} newRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(newRole: NewRole, options: any = {}): FetchArgs {
            // verify required parameter 'newRole' is not null or undefined
            if (newRole === null || newRole === undefined) {
                throw new RequiredError('newRole','Required parameter newRole was null or undefined when calling addRole.');
            }
            const localVarPath = `/api/Roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewRole" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(newRole || {}) : (newRole || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromRole(roleId: string, permission: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling removePermissionFromRole.');
            }
            // verify required parameter 'permission' is not null or undefined
            if (permission === null || permission === undefined) {
                throw new RequiredError('permission','Required parameter permission was null or undefined when calling removePermissionFromRole.');
            }
            const localVarPath = `/api/Roles/permission`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRole(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeRole.');
            }
            const localVarPath = `/api/Roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roles(options: any = {}): FetchArgs {
            const localVarPath = `/api/Roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRole(roleId: string, permission: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).addPermissionToRole(roleId, permission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NewRole} newRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(newRole: NewRole, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultRole> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).addRole(newRole, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromRole(roleId: string, permission: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).removePermissionFromRole(roleId, permission, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRole(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).removeRole(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultRole> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).roles(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPermissionToRole(roleId: string, permission: string, options?: any) {
            return RolesApiFp(configuration).addPermissionToRole(roleId, permission, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NewRole} newRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRole(newRole: NewRole, options?: any) {
            return RolesApiFp(configuration).addRole(newRole, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} roleId 
         * @param {string} permission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePermissionFromRole(roleId: string, permission: string, options?: any) {
            return RolesApiFp(configuration).removePermissionFromRole(roleId, permission, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRole(id: string, options?: any) {
            return RolesApiFp(configuration).removeRole(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roles(options?: any) {
            return RolesApiFp(configuration).roles(options)(fetch, basePath);
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @param {string} roleId 
     * @param {string} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addPermissionToRole(roleId: string, permission: string, options?: any) {
        return RolesApiFp(this.configuration).addPermissionToRole(roleId, permission, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NewRole} newRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public addRole(newRole: NewRole, options?: any) {
        return RolesApiFp(this.configuration).addRole(newRole, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} roleId 
     * @param {string} permission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public removePermissionFromRole(roleId: string, permission: string, options?: any) {
        return RolesApiFp(this.configuration).removePermissionFromRole(roleId, permission, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public removeRole(id: string, options?: any) {
        return RolesApiFp(this.configuration).removeRole(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public roles(options?: any) {
        return RolesApiFp(this.configuration).roles(options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private'} type 
         * @param {string} [values] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(name: string, type: 'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private', values?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling addTag.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling addTag.');
            }
            const localVarPath = `/api/Tags/AddTag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (values !== undefined) {
                localVarQueryParameter['values'] = values;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTags(filter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Tags/AllTags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeTag.');
            }
            const localVarPath = `/api/Tags/RemoveTag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagName(id: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTagName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateTagName.');
            }
            const localVarPath = `/api/Tags/UpdateTagName`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagValues(id: string, values: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTagValues.');
            }
            // verify required parameter 'values' is not null or undefined
            if (values === null || values === undefined) {
                throw new RequiredError('values','Required parameter values was null or undefined when calling updateTagValues.');
            }
            const localVarPath = `/api/Tags/UpdateTagValues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (values !== undefined) {
                localVarQueryParameter['values'] = values;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private'} type 
         * @param {string} [values] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(name: string, type: 'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private', values?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultTagItem> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).addTag(name, type, values, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTags(filter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultTagItem> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).allTags(filter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).removeTag(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagName(id: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).updateTagName(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagValues(id: string, values: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).updateTagValues(id, values, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private'} type 
         * @param {string} [values] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(name: string, type: 'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private', values?: string, options?: any) {
            return TagsApiFp(configuration).addTag(name, type, values, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTags(filter?: string, skip?: number, count?: number, options?: any) {
            return TagsApiFp(configuration).allTags(filter, skip, count, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(id: string, options?: any) {
            return TagsApiFp(configuration).removeTag(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagName(id: string, name: string, options?: any) {
            return TagsApiFp(configuration).updateTagName(id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} values 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagValues(id: string, values: string, options?: any) {
            return TagsApiFp(configuration).updateTagValues(id, values, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private'} type 
     * @param {string} [values] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public addTag(name: string, type: 'None' | 'Bool' | 'String' | 'Number' | 'Enum' | 'Url' | 'Private', values?: string, options?: any) {
        return TagsApiFp(this.configuration).addTag(name, type, values, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [filter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public allTags(filter?: string, skip?: number, count?: number, options?: any) {
        return TagsApiFp(this.configuration).allTags(filter, skip, count, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public removeTag(id: string, options?: any) {
        return TagsApiFp(this.configuration).removeTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagName(id: string, name: string, options?: any) {
        return TagsApiFp(this.configuration).updateTagName(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} values 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTagValues(id: string, values: string, options?: any) {
        return TagsApiFp(this.configuration).updateTagValues(id, values, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(newUser: NewUser, options: any = {}): FetchArgs {
            // verify required parameter 'newUser' is not null or undefined
            if (newUser === null || newUser === undefined) {
                throw new RequiredError('newUser','Required parameter newUser was null or undefined when calling addUser.');
            }
            const localVarPath = `/api/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(newUser || {}) : (newUser || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserRole(id: string, roleId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling changeUserRole.');
            }
            const localVarPath = `/api/Users/role`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} normal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserState(id: string, normal: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling changeUserState.');
            }
            // verify required parameter 'normal' is not null or undefined
            if (normal === null || normal === undefined) {
                throw new RequiredError('normal','Required parameter normal was null or undefined when calling changeUserState.');
            }
            const localVarPath = `/api/Users/state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (normal !== undefined) {
                localVarQueryParameter['normal'] = normal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [nameFilter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        users(nameFilter?: string, skip?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nameFilter !== undefined) {
                localVarQueryParameter['nameFilter'] = nameFilter;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(newUser: NewUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).addUser(newUser, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserRole(id: string, roleId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).changeUserRole(id, roleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} normal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserState(id: string, normal: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResult> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).changeUserState(id, normal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [nameFilter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        users(nameFilter?: string, skip?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPagedResultUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).users(nameFilter, skip, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(newUser: NewUser, options?: any) {
            return UsersApiFp(configuration).addUser(newUser, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserRole(id: string, roleId?: string, options?: any) {
            return UsersApiFp(configuration).changeUserRole(id, roleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} normal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserState(id: string, normal: boolean, options?: any) {
            return UsersApiFp(configuration).changeUserState(id, normal, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [nameFilter] 
         * @param {number} [skip] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        users(nameFilter?: string, skip?: number, count?: number, options?: any) {
            return UsersApiFp(configuration).users(nameFilter, skip, count, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {NewUser} newUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(newUser: NewUser, options?: any) {
        return UsersApiFp(this.configuration).addUser(newUser, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [roleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserRole(id: string, roleId?: string, options?: any) {
        return UsersApiFp(this.configuration).changeUserRole(id, roleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} normal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changeUserState(id: string, normal: boolean, options?: any) {
        return UsersApiFp(this.configuration).changeUserState(id, normal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [nameFilter] 
     * @param {number} [skip] 
     * @param {number} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public users(nameFilter?: string, skip?: number, count?: number, options?: any) {
        return UsersApiFp(this.configuration).users(nameFilter, skip, count, options)(this.fetch, this.basePath);
    }

}

/**
 * WxApi - fetch parameter creator
 * @export
 */
export const WxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [signature] 
         * @param {string} [timestamp] 
         * @param {string} [nonce] 
         * @param {string} [echostr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(signature?: string, timestamp?: string, nonce?: string, echostr?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Wx`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (echostr !== undefined) {
                localVarQueryParameter['echostr'] = echostr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WxApi - functional programming interface
 * @export
 */
export const WxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [signature] 
         * @param {string} [timestamp] 
         * @param {string} [nonce] 
         * @param {string} [echostr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(signature?: string, timestamp?: string, nonce?: string, echostr?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WxApiFetchParamCreator(configuration).get(signature, timestamp, nonce, echostr, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WxApi - factory interface
 * @export
 */
export const WxApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [signature] 
         * @param {string} [timestamp] 
         * @param {string} [nonce] 
         * @param {string} [echostr] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(signature?: string, timestamp?: string, nonce?: string, echostr?: string, options?: any) {
            return WxApiFp(configuration).get(signature, timestamp, nonce, echostr, options)(fetch, basePath);
        },
    };
};

/**
 * WxApi - object-oriented interface
 * @export
 * @class WxApi
 * @extends {BaseAPI}
 */
export class WxApi extends BaseAPI {
    /**
     * 
     * @param {string} [signature] 
     * @param {string} [timestamp] 
     * @param {string} [nonce] 
     * @param {string} [echostr] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WxApi
     */
    public get(signature?: string, timestamp?: string, nonce?: string, echostr?: string, options?: any) {
        return WxApiFp(this.configuration).get(signature, timestamp, nonce, echostr, options)(this.fetch, this.basePath);
    }

}

